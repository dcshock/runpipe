// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package repository

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const deletePipelineParkedRun = `-- name: DeletePipelineParkedRun :exec
DELETE FROM pipeline_parked_run WHERE run_id = $1
`

func (q *Queries) DeletePipelineParkedRun(ctx context.Context, runID string) error {
	_, err := q.db.Exec(ctx, deletePipelineParkedRun, runID)
	return err
}

const getPipelineParkedRunsDueForResume = `-- name: GetPipelineParkedRunsDueForResume :many
SELECT run_id, pipeline_name, next_stage_index, input_for_next_stage, resume_at
FROM pipeline_parked_run
WHERE resume_at <= now()
ORDER BY resume_at
`

type GetPipelineParkedRunsDueForResumeRow struct {
	RunID             string    `json:"run_id"`
	PipelineName      string    `json:"pipeline_name"`
	NextStageIndex    int32     `json:"next_stage_index"`
	InputForNextStage []byte    `json:"input_for_next_stage"`
	ResumeAt          time.Time `json:"resume_at"`
}

func (q *Queries) GetPipelineParkedRunsDueForResume(ctx context.Context) ([]GetPipelineParkedRunsDueForResumeRow, error) {
	rows, err := q.db.Query(ctx, getPipelineParkedRunsDueForResume)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPipelineParkedRunsDueForResumeRow
	for rows.Next() {
		var i GetPipelineParkedRunsDueForResumeRow
		if err := rows.Scan(
			&i.RunID,
			&i.PipelineName,
			&i.NextStageIndex,
			&i.InputForNextStage,
			&i.ResumeAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertPipelineRun = `-- name: InsertPipelineRun :exec
INSERT INTO pipeline_run (run_id, name, payload, status)
VALUES ($1, $2, $3, 'running')
`

type InsertPipelineRunParams struct {
	RunID   string `json:"run_id"`
	Name    string `json:"name"`
	Payload []byte `json:"payload"`
}

func (q *Queries) InsertPipelineRun(ctx context.Context, arg InsertPipelineRunParams) error {
	_, err := q.db.Exec(ctx, insertPipelineRun, arg.RunID, arg.Name, arg.Payload)
	return err
}

const insertPipelineRunStage = `-- name: InsertPipelineRunStage :exec
INSERT INTO pipeline_run_stage (pipeline_run_id, stage_index, input_json, status)
VALUES ($1, $2, $3, 'running')
`

type InsertPipelineRunStageParams struct {
	PipelineRunID string `json:"pipeline_run_id"`
	StageIndex    int32  `json:"stage_index"`
	InputJson     []byte `json:"input_json"`
}

func (q *Queries) InsertPipelineRunStage(ctx context.Context, arg InsertPipelineRunStageParams) error {
	_, err := q.db.Exec(ctx, insertPipelineRunStage, arg.PipelineRunID, arg.StageIndex, arg.InputJson)
	return err
}

const updatePipelineRunComplete = `-- name: UpdatePipelineRunComplete :exec
UPDATE pipeline_run
SET status = $2, result = $3, error = $4, updated_at = now()
WHERE run_id = $1
`

type UpdatePipelineRunCompleteParams struct {
	RunID  string      `json:"run_id"`
	Status string      `json:"status"`
	Result []byte      `json:"result"`
	Error  pgtype.Text `json:"error"`
}

func (q *Queries) UpdatePipelineRunComplete(ctx context.Context, arg UpdatePipelineRunCompleteParams) error {
	_, err := q.db.Exec(ctx, updatePipelineRunComplete,
		arg.RunID,
		arg.Status,
		arg.Result,
		arg.Error,
	)
	return err
}

const updatePipelineRunStage = `-- name: UpdatePipelineRunStage :exec
UPDATE pipeline_run_stage
SET output_json = $3, status = $4, error = $5, duration_ms = $6, updated_at = now()
WHERE pipeline_run_id = $1 AND stage_index = $2
`

type UpdatePipelineRunStageParams struct {
	PipelineRunID string      `json:"pipeline_run_id"`
	StageIndex    int32       `json:"stage_index"`
	OutputJson    []byte      `json:"output_json"`
	Status        string      `json:"status"`
	Error         pgtype.Text `json:"error"`
	DurationMs    pgtype.Int8 `json:"duration_ms"`
}

func (q *Queries) UpdatePipelineRunStage(ctx context.Context, arg UpdatePipelineRunStageParams) error {
	_, err := q.db.Exec(ctx, updatePipelineRunStage,
		arg.PipelineRunID,
		arg.StageIndex,
		arg.OutputJson,
		arg.Status,
		arg.Error,
		arg.DurationMs,
	)
	return err
}

const upsertPipelineParkedRun = `-- name: UpsertPipelineParkedRun :exec
INSERT INTO pipeline_parked_run (run_id, pipeline_name, next_stage_index, input_for_next_stage, resume_at, updated_at)
VALUES ($1, $2, $3, $4, $5, now())
ON CONFLICT (run_id) DO UPDATE SET
    pipeline_name = EXCLUDED.pipeline_name,
    next_stage_index = EXCLUDED.next_stage_index,
    input_for_next_stage = EXCLUDED.input_for_next_stage,
    resume_at = EXCLUDED.resume_at,
    updated_at = now()
`

type UpsertPipelineParkedRunParams struct {
	RunID             string    `json:"run_id"`
	PipelineName      string    `json:"pipeline_name"`
	NextStageIndex    int32     `json:"next_stage_index"`
	InputForNextStage []byte    `json:"input_for_next_stage"`
	ResumeAt          time.Time `json:"resume_at"`
}

func (q *Queries) UpsertPipelineParkedRun(ctx context.Context, arg UpsertPipelineParkedRunParams) error {
	_, err := q.db.Exec(ctx, upsertPipelineParkedRun,
		arg.RunID,
		arg.PipelineName,
		arg.NextStageIndex,
		arg.InputForNextStage,
		arg.ResumeAt,
	)
	return err
}
